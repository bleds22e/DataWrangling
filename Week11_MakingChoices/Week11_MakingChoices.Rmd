---
title: 'Week 11: Making Choices'
author: "Ellen Bledsoe"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Making Choices

## Conditionals

When we want to make choices in R, we are most often using some type of conditional statement. 

We talked about conditional statements early in the class when we talked about conditional sub-setting, and we've continued to use them frequently throughout the course in our `filter` functions! 

Here are some examples below.

```{r}
weight > 50
species == "DM"
```

When we run these lines of code, these statements produce an output that is a generate a `"logical"` data type.

* `TRUE` if the condition is satisfied 
* `FALSE` if the condition is not satisfied

As a reminder, these are not the same as strings "TRUE" and "FALSE." These are a special type of value called "boolean." 

In some ways, they are similar to `NA` values. True `NA` values do not go in quotation marks because they are a special data type; the same is true for `TRUE` (or `T`) and `FALSE` (`F`).

### Conditional Operators

As we've seen in previous classes, conditional statements can be created with a number of different operators.

We have the "traditional" operators:

  * `==` for equals
  * `!=` for not equals
  * `<` and `>` for less than or greater than
  * `<=`, `>=` for less than or equal to or greater than or equal to

For example:

```{r}
10 >= 5
```

There are other operators that we have not yet used, such as `%in%`. This is a very handy little operator!

It checks to see if a value is present in a vector of possible values.

```{r}
"DM" %in% c("DM", "DO", "DS")
"PP" %in% c("DM", "DO", "DS")
```

There are also a number of functions that return these boolean data types.

For example, the `is.na()` function returns `TRUE` or `FALSE` depending on whether a value is null or not.

```{r}
is.na(NA)
is.na(5)
```

### Reversing Conditions

When we want the opposite of a certain condition, we can use the `!` operator to negate the condition.

In doing so, it reverses the boolean values that are returned (`TRUE` becomes `FALSE` and `FALSE` becomes `TRUE`).

```{r}
!(10 >= 5)
!is.na(c(4, NA, 76))
```

> Work on Question 1: Choice Operators

### `if` statements

* Conditional statements generate logical values
* `if` statements use conditional statements to control flow of the program

```{r}
if (the conditional statement is TRUE ) {
  do something
}
```

* Example

```{r}
x = 6
if (x > 5){
  x = x * 2
}
x
```

* `x > 5` is `TRUE`, so the code in the `if` runs
* `x` is now 6 * 2 or 12
* Change `x` to 4

```{r}
x = 4
if (x > 5){
  x = x * 2
}
x
```

* `x > 5` is `FALSE`, so the code in the `if` doesn't run
* `x` is still 4
* This is *not* a function, so everything that happens in the if statement
  influences the global environment

* Different mass calculations for different vegetation types

```{r}
veg_type <- "shrub"
volume <- 16.08
if (veg_type == "shrub") {
  mass <- 2.65 * volume^0.9
  }
mass
```

> Do Task 1 in [Basic If Statements]({{ site.baseurl }}/exercises/Making-choices-basic-if-statements-R).

* Often want to chose one of several options
* Can add more conditions and associated actions with `else if`
 
```{r}
veg_type <- "grass"
volume <- 16.08
if (veg_type == "shrub") {
  mass <- 2.65 * volume^0.9
} else if (veg_type == "grass") {
  mass <- 0.65 * volume^1.2
}
mass
```

* Checks the first condition
* If `TRUE` runs that condition's code and skips the rest
* If not it checks the next one until it runs out of conditions

* Can specify what to do if none of the conditions is `TRUE` using `else` on its own

```{r}
veg_type <- "tree"
volume <- 16.08
if (veg_type == "shrub") {
  mass <- 2.65 * volume^0.9
} else if (veg_type == "grass") {
  mass <- 0.65 * volume^1.2
} else {
  mass <- NA
}
mass
```

> Do Tasks 2-3 in [Basic If Statements]({{ site.baseurl }}/exercises/Making-choices-basic-if-statements-R).

### Using Conditionals Inside Functions

* We've used a conditional to estimate mass differently for different types of vegetation
* This is the kind of code we are going to want to reuse, so let's move it into a function
* We do this by placing the same code inside of a function
* And making sure that the function takes all required variables as input

```{r}
est_mass <- function(volume, veg_type){
  if (veg_type == "shrub") {
    mass <- 2.65 * volume^0.9
  } else if (veg_type == "grass") {
    mass <- 0.65 * volume^1.2
  } else {
    mass <- NA
  }
  return(mass)
}
```

* We can then run this function with different vegetation types and get different estimates for mass

```{r}
est_mass(1.6, "shrub")
est_mass(1.6, "grass")
est_mass(24, "tree")
```

* Let's walk through how this code executes using the debugger
* When we call the function the first thing that happens is that 1.6 gets assigned to `volume` and `"tree"` gets assigned to `veg_type`
* The code then checks to see if `veg_type` is equal to `"shrub"`
* It isn't so the code then checks to see if `veg_type` is equal to `"grass"`
* It isn't so the code then hits the `else` statement and executes the code in the `else` block
* It assigns `NA` to mass
* It then finishes the if/else if/else statement and returns the value for `mass`, which is `NA` to the global environment

> Do Tasks 4 in [Basic If Statements]({{ site.baseurl }}/exercises/Making-choices-basic-if-statements-R).

### Multiple ifs vs else if

* Multiple ifs check each conditional separately
* Executes code of all conditions that are `TRUE`

```{r}
x <- 5
if (x > 2){
  x * 2
}
if (x > 4){
  x * 4
}
x
```

* `else if` checks each condition sequentially
* Executes code for the first condition that is `TRUE`

```{r}
x <- 5
if (x > 2){
  x * 2
} else if (x > 4){
  x * 4
}
x
```

### Automatically extracting functions

* Can pull code out into functions
* Highlight the code
* Code -> Extract Function
* Provide a name for the function

### Nested conditionals

* Sometimes decisions are more complicated
* For example we might have different equations for some vegetation types based on the age of the plant
* Can "nest" conditionals inside of one another

```{r}
est_mass <- function(volume, veg_type, age){
  if (veg_type == "shrub") {
    if (age < 5) {
      mass <- 1.6 * volume^0.8
    } else {
      mass <- 2.65 * volume^0.9
    }
  }
  } else if (veg_type == "grass" | veg_type == "sedge") {
    mass <- 0.65 * volume^1.2
  } else {
    mass <- NA
  }
  return(mass)
}

est_mass(1.6, "shrub", age = 2)
est_mass(1.6, "shrub", age = 6)
```

* First checks if the vegetation type is "shrub"
* If it is checks to see if it is < 5 years old
* If so does one calculation, if not does another
* But nesting can be difficult to follow so try to minimize it

> Assign the rest of the exercises.

## Making Choices in the `tidyverse`

```{r}
install.packages("lterdatasampler")
library(lterdatasampler)
```

`if_else`

`case_when`

With `mutate`

Add 1 question in assignment using if_else, case_when, and if {} else if to do the same task
